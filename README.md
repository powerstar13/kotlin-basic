# 코틀린 기초

1. 변수
   - 변수 선언
   - 지연 할당
   - val, var 키워드
   - 탑-레벨 변수 선언
2. 함수
   - 기본적인 함수 선언 스타일 (fun 키워드 사용)
   - 표현식 스타일
   - 표현식 & 반환타입 생략
   - 반환타입이 없는 함수는 Unit이라는 특별한 타입을 반환한다. (java의 void와 유사하다고 보면 된다.)
   - 디폴트 파라미터
   - named arguments 기법
3. 흐름제어
   - if-else 표현식
   - when식
   - for loop
   - while문
4. 널 안정성
   - 안전 연산자(`?`)
   - 엘비스 연산자(`?:`)
   - 단언 연산자(`!!`)
5. 예외처리
   - try-catch 표현식
   - Nothing 반환 메서드
   - 엘빈스 연산자와 Nothing 반환 메서드의 조합의 유용성
6. 클래스와 프로퍼티
   - `class` 키워드를 사용하여 클래스를 선언한다.
   - 코틀린의 클래스는 본문을 생략할 수 있다.
   - 코틀린의 생성자는 기본 생성자와 하나 이상의 보조 생성자가 존재할 수 있다.
   - 기본 생성자는`constructor`를 생략할 수 있다.
   - 코틀린에선 클래스에 프로퍼티를 선언할 때 후행 쉼표(`,`) `trailing comma`를 사용할 수 있다.
     - 후행 쉼표를 쓰면 이전의 마지막 줄을 수정하지 않고 프로퍼티를 쉽게 추가할 수 있고, git에서 diff 등으로 코드를 비교했을 때 변경사항을 명확히 알 수 있다.
   - 코틀린의 프로퍼티는 `val`, `var` 키워드를 모두 사용할 수 있다.
   - 프로퍼티를 수정하거나 사용하려면 참조를 사용하면 된다.
   - 코틀린은 var로 선언된 프로퍼티는 `getter`, `setter`를 자동으로 생성한다.
   - `val`로 선언된 프로퍼티는 `getter`만 존재한다.
   - 코틀린은 커스텀 getter를 만들 수 있다.
   - var로 선언된 프로퍼티에 한하여 커스텀 setter를 만들 수 있다.
   - 코틀린은 getter, setter에서 `field`라는 식별자를 사용해 필드의 참조에 접근하는데 이를 `Backing Feild`에 접근한다고 한다.
       - Backing Field가 필요한 이유
          - Backing Field를 사용하지 않고 변수명에 직접 값을 하려고 할 경우… 코틀린에서 프로퍼티에 값을 할당할 때, 실제론 setter를 사용하는데 이때 무한 재귀 즉 `StackOverflow`가 발생할 수 있다.
   13. 코틀린은 프로퍼티를 사용해 상태를 나타낼 수있기 때문에 자바보다 객체지향적으로 코드를 작성할 수 있다.
7. 상속
   - 자바의 모든 클래스의 조상은 `Object`, 코틀린에서 모든 클래스의 조상은 `Any`
   - 코틀린의 클래스는 기본적으로 final 클래스와 같이 상속을 막고, 꼭 필요한 경우 `open` 키워드로 상속을 허용할 수 있다. 
   - 하위 클래스에서 상위 클래스를 확장하려면 클래스 뒤에 `:`을 추가하고 상위 클래스를 작성한다. 
   - 함수나 프로퍼티를 재정의할 때도 마찬가지로 `open` 키워드로 오버라이드에 대해 허용해야 한다.
   - `override`된 함수나 프로퍼티는 기본적으로 open되어 있으므로 하위 클래스에서 오버라이드를 막기 위해선 final을 앞에 붙인다. 
   - 하위 클래스에서 상위 클래스의 함수나 프로퍼티를 접근할 땐 `super` 키워드를 사용한다. 
   - 코틀린은 `abstract` 키워드를 사용해 추상클래스도 제공한다. 
     - 이때 하위 클래스에서 구현해야하는 프로퍼티나 함수 또한 abstract 키워드를 사용한다.
8. 인터페이스
   - 코틀린의 인터페이스는 `interface` 키워드를 사용해 정의할 수 있다.
   - 코틀린의 인터페이스 내부에는 추상 함수와 자바 8의 디폴트 메서드처럼 구현을 가진 함수를 모두 정의할 수 있다.
   - 클래스에서 인터페이스를 구현할 때는 `:`를 붙이고 인터페이스의 이름을 적는다.
      - 상속과 다른 점은 `()` 생성자 호출이 없다는 것이다.
   - 코틀린의 인터페이스는 프로퍼티가 존재할 수 있다.
   - 코틀린 인터페이스는 상위 인터페이스를 가질 수 있다.
   - 클래스는 하나 이상의 인터페이스를 구현할 수 있다.
      - 이때 동일한 시그니처를 가진 함수가 있는 경우 `super<인터페이스>`를 사용해 호출할 수 있다.
9. 열거형
   - 코틀린은 서로 연관된 상수들의 집합을 `enum class`를 사용해서 정의할 수 있다.
   - enum 클래스도 클래스이므로 생성자와 프로퍼티를 정의할 수 있다.
   - 정의된 상수 목록 뒤에 함수를 정의할 경우 세미콜론(`;`)을 붙여야 한다.
   - abstract 함수를 가질 수 있고, 각각의 상수는 익명 클래스 형태로 abstract 함수를 구현할 수 있다.
   - enum 클래스에서 인터페이스를 구현할 수 있다.
   - `valueOf(value: String) : String`를 사용해서 enum 클래스를 생성할 수 있다.
   - enum 클래스의 동등성 비교는 `==`를 사용한다.
   - enum 클래스의 상수를 나열하려면 `values() : Array<EnumClass>`를 사용한다.
   - 상수는 제공하는 2개의 프로퍼티(name, ordinal)를 사용해 이름을 얻거나 순서를 얻을 수 있다.